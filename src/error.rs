use crate::libarchive;
use std::ffi::CStr;

#[derive(thiserror::Error, Debug)]
pub enum Error {
    #[error("IO error: {0:?}")]
    Io(#[from] std::io::Error),
    /// `Extraction` error is a wrapper for errors generated by libarchive.
    #[error("Extraction error: {0}")]
    Extraction(String),
    /// `PathNotUft8` error happens when passing in a path which is not UTF8 encoded.
    /// Archive-reader relies on UTF8 encoded path to load archives.
    #[error("Archive path cannot be converted to utf8")]
    PathNotUtf8,
    /// `Encoding` error happens when the giving decoding function failed to decode
    /// the entry name.
    #[error("Entry name cannot be decoded with given encoding")]
    Encoding,
    #[error("Failed to convert string to cstring: {0:?}")]
    StringError(#[from] std::ffi::NulError),
    /// Unspecified error
    #[error("Unknown error happened")]
    Unknown,
}

#[cfg(test)]
impl PartialEq for Error {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Error::Extraction(my_msg), Error::Extraction(other_msg)) => my_msg == other_msg,
            (Error::Io(my_err), Error::Io(other_err)) => my_err.kind() == other_err.kind(),
            (Error::PathNotUtf8, Error::PathNotUtf8)
            | (Error::Unknown, Error::Unknown)
            | (Error::StringError(_), Error::StringError(_)) => true,
            _ => false,
        }
    }
}

pub type Result<T, E = Error> = std::result::Result<T, E>;

pub(crate) fn analyze_result(
    result: std::os::raw::c_int,
    handle: *mut libarchive::archive,
) -> Result<()> {
    match result {
        libarchive::ARCHIVE_OK | libarchive::ARCHIVE_WARN => Ok(()),
        _ => unsafe {
            let error_string = libarchive::archive_error_string(handle);
            if !error_string.is_null() {
                return Err(Error::Extraction(
                    CStr::from_ptr(error_string).to_string_lossy().to_string(),
                ));
            }
            let error_code = libarchive::archive_errno(handle);
            if error_code != 0 {
                Err(std::io::Error::from_raw_os_error(error_code).into())
            } else {
                Err(Error::Unknown)
            }
        },
    }
}

pub(crate) fn path_does_not_exist<S: Into<String>>(message: S) -> Error {
    Error::Io(std::io::Error::new(
        std::io::ErrorKind::NotFound,
        message.into(),
    ))
}

pub(crate) fn invalid_data<S: Into<String>>(message: S) -> Error {
    Error::Io(std::io::Error::new(
        std::io::ErrorKind::InvalidData,
        message.into(),
    ))
}
